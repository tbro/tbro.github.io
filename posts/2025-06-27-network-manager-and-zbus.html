<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Network Manager and zbus</title>
	<link rel="stylesheet" type="text/css" href="index.css">
    </head>
    <body>
    <div id="body">
      <h2>Network Manager and zbus</h2>
      <h1>NetworkManager and Zbus</h1>
<p>Traveling heavily recently, I've become fatigued from typing all the WiFi
passphrases. My phone can happily connect via a QR code. Why does my laptop
required so much typing, I asked. So I proposed a simple project.</p>
<p>Researching how I might use my web-cam to connect to WiFi networks, I came
across the <a href="https://rbs.io/2024/07/network-manager-and-rusts-zbus/">Network Manager and Rust's Zbus article on
rbs.io</a>. I use
<code>NewtworkManager</code> and I enjoy working with rust. I know next to nothing about
<code>DBus</code>, but I thought some knowledge of hacking Linux networks couldn't do me any
harm. Besides I had some free time.</p>
<p>The above article set me on the right path. The <code>zbus</code> documentation is still a
little obscure in some salient details, however. Hopefully this post will help
fill those in. The finished code is hosted in the
<a href="https://github.com/tbro/scampi/tree/main">scampi</a> repo.</p>
<h2>Replacing nested <code>HashMap</code>s with structs.</h2>
<p>I first needed to generate a <code>settings.rs</code> with <code>zbus-xmlgen</code> as described in
the above article. It is also straightforward to create a connection by building
the nested structures of <code>HashMaps</code> also described there. While that solution
works, it is tedious, unsightly and doesn't make the most of rust's type
system. Finding the <a href="https://github.com/dbus2/zbus/issues/312">issue for using <code>DeserializeStruct</code> with nested
structs</a> closed, I hoped there might
now be a more ergonomic way forward.</p>
<p>With the help of the <a href="https://dbus2.github.io/zbus/faq.html">zbus book</a> I
managed to piece together a solution that feels a little more rust-like. Of
course there are many pieces to the puzzle. You need <code>serde</code> and the <code>zvariant::Type</code>
macro. But all that is gleaned fairly easily from the documentation, I think. The more
salient discovery was that <code>zbus</code> allows declaring <a href="https://www.alteeve.com/w/List_of_DBus_data_types">DBbus
signatures</a> on your
types. This is done via a macro, like so:</p>
<pre><code class="language-">#[zvariant(signature = &quot;a{sa{sv}}&quot;)]`

struct MyType{..}
</code></pre>
<p>Declaring the correct signature(<code>a{sa{sv}}</code>) on the struct passed to
<code>NetworkManager</code>s <code>Settings.add_connection()</code> allowed it to navigate <code>Dbus</code>'s
type system. Its children don't have any children of their own, so
<code>SerializedDict</code> and <code>DeserializeDict</code> works fine on them. For a more complete
example you can <a href="https://github.com/tbro/scampi/blob/9642b1a0ee6175469803bf572e13c90915b7d9e9/src/network_manager/mod.rs#L63-L73">have a look at the code</a>.</p>
<p>I believe I could go further and replace some fields defined as <code>String</code> with
more appropriate types, but it's one more thing learn and I think this is good
enough for now.</p>

    </div>
  </body>
</html>
